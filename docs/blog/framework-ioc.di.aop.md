# IOC DI AOP概念解读

## IOC - Inversion of Control
> IOC控制反转， 控制权从应用程序转移到框架(如IOC容器)，是一种设计模式

此处关键字为“反转”，如果不反转，依赖关系是怎么样呢?如果A要使用B的方法，需要在A里面引入B

``` javascript 
// A.js
const B = require('B')
const b = new B({
  ...initParams
})
```

当然了，除了这种最基本的引入之外，还有很多设计模式可以实现依赖引入，大同小异，不反转时，只有A主动获取B之后，才能用到B。这时C也用到了B，C又引用了A，如果后面加需求，B需要使用A的方法，这种重复引用，反复引用的现象是很恶心的。

反转做了什么事呢? A要调用B的话，A并不需要主动获取B，而是由其它人自动将B送上门来。这个“其它人”就是容器。描述了依赖关系，在使用时容器来做管理。

## DI - Dependency Injection
> DI依赖注入，将相互依赖的对象分离，在配置中描述依赖关系，这些关系在应用时才被建立。

如果IOC是一种设计模式，或者叫思想，那么DI是实现这种思想的一种方式。同时也可以通过观察者模式、模板方法模式等实现IOC，咱们拿DI举例。

awilix是一个DI框架，用它在应用中实现IOC。创建容器对依赖关系做管理。

非IOC架构中，应用程序来决定引用哪些依赖，然后主动实例化;现在我们把这些工作交给IOC容器来完成，整个依赖对象的实例化、生命周期全部由容器接管,与业务代码高度解耦。

## AOP面向切面编程
> AOP是一种编程范式，跟面向过程、面向对象、函数式等编程范式是同等概念。是指在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想

举个栗子:

日志埋点、权限校验等侵入性比较强，又比较完整的模块，可能需要在不少地方调用该模块的方法，按面向对象思想，哪里用哪里引，这个方法遍地开花，不好维护，此时面向切面编程就很好解决了该问题。

``` javascript 
function log(logData){
  console.log(logData)
}

function Auth(userType){
  if(userType > 0){
    alert("无权限")
  }
}

function getRoute(key) {
    return this.$route[key];
}
const newGetRoute = function(key) {
    Auth(user.type);
    getRoute(key);
    log('some log')
}
```

上面的案例简单描述了log和Auth对getRoute方法的侵入，事实上，Auth和log此时变成了该方法的两个pre和post的 生命周期函数，在真正执行前后做了你想做的事情。redux里面到处都是

## 总结
总而言之:抛开业务类型和项目规模谈架构思想都是耍流氓，用各种骚操作完成todoList，除了学习需要就是无病呻吟。学习架构思想时又不能让业务喧宾夺主，只能用该思想完成较为简单的业务逻辑，咱们去体会，当你需要时你就知道了。引用张小龙说微信新功能的表述:

> “你未看此花时，此花与汝同归于寂;你来看此花时，则此花颜色一时明白起来”;--王阳明

微信有很多强大的功能不去大势运营，不让他们打扰用户的的使用，当你需要用到时，发现他在。我们学架构、学思想也是这样，拥有这个能力后，不一定处处使用，当需要时，自然使出来，他就在那里。 最后祝大家在前端道路上越走越好。

